# -*- coding: utf-8 -*-
"""Ass3 - linear2 - new.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hiYK8rhMmfbr8N4U-Hej5OVEvwvBD9uu
"""

import pandas as pd
import numpy as np
from __future__ import division, print_function, unicode_literals
import matplotlib.pyplot as plt
import sklearn
import seaborn as sns

"""# Mục mới"""

from google.colab import drive
drive.mount('/content/drive')

#Nhap dữ liệu từ file data
#Xuất ra 10 dòng đầu dữ liệu

data_df=pd.read_excel('/Annotation_AllVideos_FPT_Ver1.xlsx')
data_df.head(10)

#Lấy những feature cần thiết.
m=data_df[['container','venue','time','describe how to make it','num','viewer']]
m

# Do một số bạn ghi nhầm chỗ end và start nên số âm => chuyển về thành dương
for i in range(m['time'].shape[0]):
    c=m['time'][i]
    if c<0:
        m.loc[i,'time']=-c

# # #Lấy những feature cần thiết.
# # #Tách dữ liệu thành các biến phụ thuộc và không phụ thuộc
# m=m.drop(index=m[m['num']>14].index)
# m

m

# Sử dụng sơ đồ Boxplot để tối ưu hóa dữ liệu

from typing import Tuple
from sklearn.base import BaseEstimator, TransformerMixin


def find_boxplot_boundaries(
    col: pd.Series, whisker_coeff: float = 1.5
) -> Tuple[float, float]:
    """Findx minimum and maximum in boxplot.

    Args:
        col: a pandas serires of input.
        whisker_coeff: whisker coefficient in box plot
    """
    Q1 = col.quantile(0.25)
    Q3 = col.quantile(0.75)
    IQR = Q3 - Q1
    lower = Q1 - whisker_coeff * IQR
    upper = Q3 + whisker_coeff * IQR
    return lower, upper


class BoxplotOutlierClipper(BaseEstimator, TransformerMixin):
    def __init__(self, whisker_coeff: float = 1.5):
        self.whisker = whisker_coeff
        self.lower = None
        self.upper = None

    def fit(self, X: pd.Series):
        self.lower, self.upper = find_boxplot_boundaries(X, self.whisker)
        return self

    def transform(self, X):
        return X.clip(self.lower, self.upper)

#Tối ưu hóa 2 feather time và num

clipped_total_rooms = BoxplotOutlierClipper().fit_transform(data_df["time"])
clipped_total_rooms = BoxplotOutlierClipper().fit_transform(data_df["num"])

# plt.plot(m['time'])
# plt.xlabel("epoch")
# plt.ylabel("cost")
# plt.show()

# m=m.drop(index=m[m['time']>65].index)

# plt.plot(m['time'])
# plt.ylabel("cost")
# plt.show()

#Tách dữ liệu thành biến phụ thuộc và không phụ thuộc

x=m[['container','venue','time','describe how to make it','num']].values
y=m['viewer'].values

#Sử dụng thư viện sklearn để dán nhãn cho dữ liệu dạng danh nghĩa feather "container"

from sklearn.compose import ColumnTransformer
from sklearn.preprocessing import OneHotEncoder
ct=ColumnTransformer(transformers=[('encoder',OneHotEncoder(),[0])],remainder="passthrough")
x=ct.fit_transform(x)
x

#Sử dụng thư viện sklearn để dán nhãn cho dữ liệu dạng danh nghĩa feather "num"
ct=ColumnTransformer(transformers=[('encoder',OneHotEncoder(),[8])],remainder="passthrough")
x=ct.fit_transform(x)
x

# f = m['num'].value_counts(ascending=False)
# f

# f = m['container'].value_counts(ascending=False)
# f

# f_10=f[f<157]
# f_10

# #Do cột time có một số bạn gõ nhầm start và end nên ra số âm => điều chỉnh lại thành dương

# c=x[:,4]
# for i in range(len(c)):
#     if c[i]<0:
#         c[i]=-c[i]
# x[:,4]=c
# x

#danh sách các địa điểm ăn uống từ dữ liệu

from sklearn.preprocessing import LabelEncoder

gle = LabelEncoder()
genre_labels = gle.fit_transform(data_df['venue'])
genre_mappings = {index: label for index, label in
                  enumerate(gle.classes_)}
genre_mappings

#danh sách các dụng cụ ăn uống từ dữ liệu

from sklearn.preprocessing import LabelEncoder

gle = LabelEncoder()
genre_labels = gle.fit_transform(data_df['container'])
genre_mappings = {index: label for index, label in
                  enumerate(gle.classes_)}
genre_mappings

#Tách dữ liệu train, test tỉ lệ 80% 20%

from sklearn.model_selection import train_test_split
x,x_test,y, y_test = train_test_split(x,y,test_size=0.2, random_state=0)
y.shape

# Feature Scaling

from sklearn.preprocessing import StandardScaler
sc_X = StandardScaler()
x = sc_X.fit_transform(x)
x_test = sc_X.transform(x_test)
sc_y = StandardScaler()

#Thuật toán gradient decent

def linear(x,y,alpha,epoch):
    one = np.ones((x.shape[0], 1))
    x = np.concatenate((one, x), axis = 1)
    n=x.shape[1]
    theta_gd = np.ones(n)
    h=np.dot(x,theta_gd)
    cost=np.ones(epoch)
    for i in range(0,epoch):
        theta_gd[0]=theta_gd[0]-(alpha/x.shape[0])*sum(h-y)
        for j in range(1,n):
            theta_gd[j]=theta_gd[j]-(alpha/x.shape[0])*sum((h-y)*x[:,j])
        h=np.dot(x,theta_gd)
        cost[i]=1/(2*x.shape[0])*sum(np.square(h-y))
    return cost, theta_gd

#Tính giá trị the_ta, learning rate = 0.0055, số lần lập 5000

cost, theta_gd=linear(x,y,0.0055,5000)
print(theta_gd)

one = np.ones((x_test.shape[0], 1))
Xbar = np.concatenate((one.T, x_test.T), axis = 0)
Xbar = Xbar.T
two=np.ones((1,3))
Predict = np.dot(Xbar, theta_gd)
Predict=Predict.astype(float)
Predict=np.round(Predict)
Predict

#Tỉ lệ phần trăm chính xác của thuật toán

from sklearn.metrics import r2_score
print(f"{r2_score(y_test,Predict)*100}%")

#In ra bảng số liệu dữ đoán kết quả

pd.DataFrame({'y':y_test,'Predicts':Predict})

plt.plot(cost)
plt.xlabel("epoch")
plt.ylabel("cost")
plt.show()

# plot the result
import matplotlib.pyplot as plt
plt.figure(figsize=(15,10))
plt.scatter(y_test,Predict)
plt.xlabel('Actual')
plt.ylabel('Predicted')
plt.title('Actual vs Predictd')

